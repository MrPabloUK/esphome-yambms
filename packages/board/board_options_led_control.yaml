# Updated : 2026.01.31
# Version : 1.1.2
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.


substitutions:
  global_status_led: "esp_light"

globals:
  # 2D grid of physical LED pointers
  # Structure: [Component Category (0-15)] -> [Specific Instance ID (0-N)]
  - id: global_led_registry
    type: std::vector<std::vector<esphome::light::LightState*>>
    initial_value: 'std::vector<std::vector<esphome::light::LightState*>>(16)'

  # ---------------------------------------------------------
  # Global Function: Update LED assignment
  # ---------------------------------------------------------
  - id: global_register_led
    type: std::function<void(int, int, light::LightState*)>
    initial_value: |-
      [](int category, int instance, light::LightState* led) {

        if (led == &id(virtual_status_light)) {
            led = nullptr; 
        }

        int computer_instance = instance - 1;
        if (category < 0 || category >= 16 || computer_instance < 0) return;

        auto &leds = id(global_led_registry)[category];
        auto &faults = id(global_instance_faults)[category];

        if (leds.size() <= computer_instance) {
          leds.resize(computer_instance + 1, nullptr);
          faults.resize(computer_instance + 1, false);
        }
        leds[computer_instance] = led;
      }


output:
  - platform: template
    id: virtual_output
    type: binary
    write_action: []

# Fake light to act as a placeholder for LED control logic
light:
  - platform: binary
    id: virtual_status_light
    output: virtual_output


interval:
  - interval: 50ms
    then:
      - lambda: |-
          // -----------------------------------------------------------------------
          // CONFIGURATION
          // -----------------------------------------------------------------------
          const uint32_t DUR_HEADER = 1000; // Blue Header Length
          const uint32_t DUR_GAP    = 500;  // Dark Gap Length
          const uint32_t DUR_PIP_ON = 200;  // Red Pip ON Length
          const uint32_t DUR_PIP_OFF= 200;  // Red Pip OFF Length
          const uint32_t DUR_NEXT   = 1000; // Pause between different fault codes

          uint32_t now = millis();
          bool global_heartbeat = (now % 2000) < 1000; // 1s ON, 1s OFF

          // -----------------------------------------------------------------------
          // 1. DATA GATHERING (The "Workload")
          // We scan the registry to build a strict job description for every unique LED.
          // -----------------------------------------------------------------------
          
          struct LedJob {
              std::vector<int> faults; // List of categories (e.g. [1, 4])
              bool has_healthy = false;
          };
          std::map<esphome::light::LightState*, LedJob> jobs;

          for (int cat = 0; cat < 16; cat++) {
             auto &leds = id(global_led_registry)[cat];
             auto &fault_flags = id(global_instance_faults)[cat];

             for (size_t i = 0; i < leds.size(); i++) {
                auto *led = leds[i];
                if (!led) continue;

                // Create or Access Job Entry
                LedJob &job = jobs[led];

                // Check specific instance health
                if (i < fault_flags.size() && fault_flags[i]) {
                    // It is Faulty. Add category to playlist if not already there.
                    bool exists = false;
                    for(int c : job.faults) { if(c == cat) exists = true; }
                    if (!exists) job.faults.push_back(cat);
                } else {
                    // It is Healthy.
                    job.has_healthy = true;
                }
             }
          }

          // -----------------------------------------------------------------------
          // 2. STATE MEMORY
          // Remembers where each LED is in its specific animation sequence.
          // -----------------------------------------------------------------------
          struct AnimState {
              int idx = 0;       // Which fault index are we playing?
              int stage = 0;     // 0=Start, 1=Blue, 2=Gap, 3=PipOn, 4=PipOff, 5=Wait
              int pips_left = 0; // Counter for blinks
              uint32_t timer = 0;// Next event time
          };
          static std::map<esphome::light::LightState*, AnimState> memory;

          // -----------------------------------------------------------------------
          // 3. EXECUTION LOOP
          // Process each LED exactly once based on its Job Description.
          // -----------------------------------------------------------------------
          
          for (auto &pair : jobs) {
              auto *led = pair.first;
              auto &job = pair.second;
              auto &mem = memory[led]; // Get persistent state
              auto call = led->make_call();

              // ===================================================================
              // MODE 1: FAULT OVERRIDE
              // If ANY faults exist, this LED enters Fault Mode. Green is forbidden.
              // ===================================================================
              if (!job.faults.empty()) {
                  
                  // Reset if index is invalid (e.g., fault cleared while playing)
                  if (mem.idx >= job.faults.size()) {
                      mem.idx = 0;
                      mem.stage = 0;
                      mem.timer = now;
                  }

                  // Wait for Timer
                  if (now < mem.timer) continue; 

                  // Animation State Machine
                  int category = job.faults[mem.idx];
                  
                  switch (mem.stage) {
                      case 0: // Setup
                          mem.stage = 1;
                          mem.pips_left = category + 1; // Cat 0 = 1 pip
                          mem.timer = now; // Immediate
                          break;

                      case 1: // Blue Header
                          if (${board_has_rgb}) { call.set_rgb(0.0, 0.0, 1.0); }
                          call.set_state(true);
                          call.perform();
                          mem.stage = 2;
                          mem.timer = now + DUR_HEADER;
                          break;

                      case 2: // Gap (Dark)
                          call.set_state(false);
                          call.perform();
                          mem.stage = 3;
                          mem.timer = now + DUR_GAP;
                          break;

                      case 3: // Red Pip ON
                          if (${board_has_rgb}) { call.set_rgb(1.0, 0.0, 0.0); }
                          call.set_state(true);
                          call.perform();
                          mem.stage = 4;
                          mem.timer = now + DUR_PIP_ON;
                          break;

                      case 4: // Red Pip OFF
                          call.set_state(false);
                          call.perform();
                          mem.pips_left--;
                          if (mem.pips_left > 0) {
                              mem.stage = 3; // More pips? Go back to ON
                              mem.timer = now + DUR_PIP_OFF;
                          } else {
                              mem.stage = 5; // Done? Go to Wait
                              mem.timer = now + DUR_PIP_OFF;
                          }
                          break;

                      case 5: // Next Fault Delay (Dark)
                          call.set_state(false);
                          call.perform();
                          mem.idx++; // Next fault in list
                          if (mem.idx >= job.faults.size()) mem.idx = 0; // Loop
                          mem.stage = 0; // Restart
                          mem.timer = now + DUR_NEXT;
                          break;
                  }
                  
                  // CRITICAL: Force loop continue to prevent Green logic from running
                  continue; 
              }

              // ===================================================================
              // MODE 2: HEALTHY HEARTBEAT
              // Only runs if Job Faults is empty AND has_healthy is true
              // ===================================================================
              if (job.has_healthy) {
                  // Reset memory so if a fault occurs later, it starts fresh
                  mem.idx = 0; 
                  mem.stage = 0;

                  if (${board_has_rgb}) { call.set_rgb(0.0, 1.0, 0.0); }
                  call.set_state(global_heartbeat);
                  call.perform();
                  continue;
              }

              // ===================================================================
              // MODE 3: OFF / DARK
              // Assigned but disconnected/null status
              // ===================================================================
              call.set_state(false);
              call.perform();
          }



  # LED Assignment Report in logs, enabled via enable_led_logging substitution
  - interval: 60s
    then:
      - lambda: |-
          // If the substitution is false, stop
          if (!${enable_led_logging}) return;

          ESP_LOGI("led_rpt", "┌──────────────────────────────┐");
          ESP_LOGI("led_rpt", "│    LED REGISTRY ASSIGNMENT   │");
          ESP_LOGI("led_rpt", "└──────────────────────────────┘");

          bool registry_empty = true;

          for (int cat = 0; cat < 16; cat++) {
            // Access the LED Registry
            auto &leds = id(global_led_registry)[cat];
            
            // Skip empty categories
            if (leds.empty()) continue;
            registry_empty = false;

            // Translate ID to Name
            std::string cat_name;
            switch(cat) {
                case 0: cat_name = "SYSTEM     "; break;
                case 1: cat_name = "BMS        "; break;
                case 2: cat_name = "CAN->INV   "; break;
                case 3: cat_name = "RS485->INV "; break;
                case 4: cat_name = "SHUNT      "; break;
                case 5: cat_name = "BALANCER   "; break;
                case 6: cat_name = "NETWORK    "; break;
                case 7: cat_name = "AUX 1      "; break;
                default: cat_name = "CAT_" + to_string(cat) + "     "; break;
            }

            // Build the status string for this category's LEDs
            std::string status_line = "";
            
            for (size_t i = 0; i < leds.size(); i++) {
                // Check if the pointer is valid
                if (leds[i] != nullptr) {
                    status_line += "[LINK] ";
                } else {
                    status_line += "[NULL] ";
                }
            }

            ESP_LOGI("led_rpt", "   %s: %s", cat_name.c_str(), status_line.c_str());
          }

          if (registry_empty) {
             ESP_LOGW("led_rpt", ">> WARNING: NO LEDS REGISTERED");
          }
          ESP_LOGI("led_rpt", "--------------------------------");