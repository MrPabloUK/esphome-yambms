# Updated : 2026.01.31
# Version : 1.1.2
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.


substitutions:
  global_status_led: "esp_light"

globals:
  # 2D grid of physical LED pointers
  # Structure: [Component Category (0-15)] -> [Specific Instance ID (0-N)]
  - id: global_led_registry
    type: std::vector<std::vector<esphome::light::LightState*>>
    initial_value: 'std::vector<std::vector<esphome::light::LightState*>>(16)'

  # ---------------------------------------------------------
  # Global Function: Update LED assignment
  # ---------------------------------------------------------
  - id: global_register_led
    type: std::function<void(int, int, light::LightState*)>
    initial_value: |-
      [](int category, int instance, light::LightState* led) {

        if (led == &id(virtual_status_light)) {
            led = nullptr; 
        }

        int computer_instance = instance - 1;
        if (category < 0 || category >= 16 || computer_instance < 0) return;

        auto &leds = id(global_led_registry)[category];
        auto &faults = id(global_instance_faults)[category];

        if (leds.size() <= computer_instance) {
          leds.resize(computer_instance + 1, nullptr);
          faults.resize(computer_instance + 1, false);
        }
        leds[computer_instance] = led;
      }


output:
  - platform: template
    id: virtual_output
    type: binary
    write_action: []

# Fake light to act as a placeholder for LED control logic
light:
  - platform: binary
    id: virtual_status_light
    output: virtual_output


interval:
  - interval: 50ms
    then:
      - lambda: |-
          // --- STATE VARIABLES ---
          static int current_stage = 0;       // 0=Search/Heartbeat, 1=BlueHeader, 2=RedPips, 3=Reset
          static int active_category = -1;    // The fault category currently being displayed (0-15)
          static int pips_count = 0;          // Counter for the blinks in Stage 2
          static uint32_t next_event_ms = 0;  // Timestamp for the next non-blocking action
          static bool heartbeat_on = false;   // Toggle state for the healthy heartbeat

          // --- TIMER CHECK ---
          uint32_t now = millis();
          if (now < next_event_ms) return;

          float bri = 0.5; // Default LED brightness

          switch (current_stage) {
            
            // =================================================================
            // STAGE 0: SEARCH & HEARTBEAT
            // Logic: Scan for faults. If found, start sequence. If clean, pulse heartbeat.
            // =================================================================
            case 0: 
              // Scan: Check all 16 categories for active fault flags
              for (int i = 1; i <= 16; i++) {
                // Start searching from the category after the last one displayed to ensure rotation
                int search_target = (active_category + i) % 16;
                bool is_faulted = (id(global_system_fault_mask) >> search_target) & 1;
                
                // Validation: Ensure the faulted category actually has an LED assigned
                bool has_valid_led = false;
                if (is_faulted) {
                    for (auto *ptr : id(global_led_registry)[search_target]) {
                        if (ptr != nullptr) {
                            has_valid_led = true;
                            break;
                        }
                    }
                }

                // Target Found: Transition to Stage 1 (Blue Header)
                if (is_faulted && has_valid_led) {
                    active_category = search_target;
                    current_stage = 1; 
                    return; // Exit immediately to start the sequence next cycle
                }
              }

              // No Faults Found: Execute Healthy Heartbeat (Category 0)
              if (!id(global_led_registry)[0].empty() && id(global_led_registry)[0][0] != nullptr) {
                auto call = id(global_led_registry)[0][0]->make_call();
                if (!heartbeat_on) {
                  // Pulse On (Green)
                  if (${board_has_rgb}) { 
                    call.set_rgb(0.0, 1.0, 0.0); 
                    call.set_brightness(bri); 
                  }
                  call.set_state(true); 
                } else { 
                  // Pulse Off
                  call.set_state(false); 
                }
                call.perform();
                
                // Toggle state and wait 1 second
                heartbeat_on = !heartbeat_on;
                next_event_ms = now + 1000;
              } 
              
              // Reset active category to ensure circular scanning works correctly next time
              active_category = -1;
              return;

            // =================================================================
            // STAGE 1: FAULT HEADER (Blue Identifier)
            // Logic: Turn LED Blue for 1 second to signal "Fault Report Starting"
            // =================================================================
            case 1: 
              for (size_t i = 0; i < id(global_led_registry)[active_category].size(); i++) {
                auto *led = id(global_led_registry)[active_category][i];
                auto &faults = id(global_instance_faults)[active_category];
                
                // Only light up the specific LED instance that has the fault
                if (led != nullptr && i < faults.size() && faults[i]) {
                  auto call = led->make_call();
                  if (${board_has_rgb}) { 
                    call.set_rgb(0.0, 0.0, 1.0); // Blue
                    call.set_brightness(bri); 
                  }
                  call.set_state(true); 
                  call.perform();
                }
              }
              
              // Transition to Stage 2
              current_stage = 2; 
              pips_count = 0; 
              
              // Hold Blue for 1000ms before moving to the gap logic in Stage 2
              next_event_ms = now + 1000; 
              break;

            // =================================================================
            // STAGE 2: IDENTITY PIPS (Red Count)
            // Logic: Blink Red X times corresponding to the Fault Category ID.
            //        Includes a dark gap after the Blue Header.
            // =================================================================
            case 2: 
              {
                int total_toggles = (active_category + 1) * 2; 
                
                // Initial Gap Logic
                // If this is the first entry (count 0), turn off the Blue Header and wait.
                if (pips_count == 0) {
                    for (auto *led : id(global_led_registry)[active_category]) {
                        if (led != nullptr) { led->make_call().set_state(false).perform(); }
                    }
                    pips_count = 1;            // Advance counter to skip this block next time
                    next_event_ms = now + 500; // 500ms Dark Gap between Blue Header and Red Pips
                    return;
                }

                // Blink Logic
                // Odd numbers are "Off" and even are "On"
                // This logic ensures the first visible pip is Red.
                bool is_on_cycle = (pips_count % 2 != 0); 
                
                for (size_t i = 0; i < id(global_led_registry)[active_category].size(); i++) {
                   auto *led = id(global_led_registry)[active_category][i];
                   auto &faults = id(global_instance_faults)[active_category];

                   if (led != nullptr && i < faults.size() && faults[i]) {
                    auto call = led->make_call();
                    if (is_on_cycle) {
                      if (${board_has_rgb}) { 
                        call.set_rgb(1.0, 0.0, 0.0); // Red
                        call.set_brightness(bri); 
                      }
                      call.set_state(true);
                    } else { 
                      call.set_state(false); 
                    }
                    call.perform();
                  }
                }
                
                pips_count++;

                // Timing Logic
                // Use total_toggles + 1 because the count started at 1 (the gap)
                if (pips_count <= total_toggles) {
                   // Grouping: Add a longer 500ms pause after every 4th pip (8 toggles)
                   // Otherwise, use standard 150ms blink speed
                   int delay = (pips_count > 1 && (pips_count - 1) % 8 == 0) ? 500 : 150;
                   next_event_ms = now + delay;
                } else {
                   // Sequence Complete. Wait 500ms for the final 'Off' to be visible.
                   current_stage = 3; 
                   next_event_ms = now + 500;
                }
              }
              break;

            // =================================================================
            // STAGE 3: CLEANUP & RESET
            // Logic: Ensure all LEDs are off before restarting the search.
            // =================================================================
            case 3: 
              if (active_category >= 0 && active_category < 16) {
                  for (auto *led : id(global_led_registry)[active_category]) {
                    if (led != nullptr) {
                      auto call = led->make_call(); 
                      call.set_state(false); 
                      call.perform();
                    }
                  }
              }
              // Reset to Stage 0 to search for the next fault
              current_stage = 0; 
              next_event_ms = now; 
              break;
          }



  # LED Assignment Report in logs, enabled via enable_led_logging substitution
  - interval: 60s
    then:
      - lambda: |-
          // If the substitution is false, stop
          if (!${enable_led_logging}) return;

          ESP_LOGI("led_rpt", "┌──────────────────────────────┐");
          ESP_LOGI("led_rpt", "│    LED REGISTRY ASSIGNMENT   │");
          ESP_LOGI("led_rpt", "└──────────────────────────────┘");

          bool registry_empty = true;

          for (int cat = 0; cat < 16; cat++) {
            // Access the LED Registry
            auto &leds = id(global_led_registry)[cat];
            
            // Skip empty categories
            if (leds.empty()) continue;
            registry_empty = false;

            // Translate ID to Name
            std::string cat_name;
            switch(cat) {
                case 0: cat_name = "SYSTEM     "; break;
                case 1: cat_name = "BMS        "; break;
                case 2: cat_name = "CAN->INV   "; break;
                case 3: cat_name = "RS485->INV "; break;
                case 4: cat_name = "SHUNT      "; break;
                case 5: cat_name = "BALANCER   "; break;
                case 6: cat_name = "NETWORK    "; break;
                case 7: cat_name = "AUX 1      "; break;
                default: cat_name = "CAT_" + to_string(cat) + "     "; break;
            }

            // Build the status string for this category's LEDs
            std::string status_line = "";
            
            for (size_t i = 0; i < leds.size(); i++) {
                // Check if the pointer is valid
                if (leds[i] != nullptr) {
                    status_line += "[LINK] ";
                } else {
                    status_line += "[NULL] ";
                }
            }

            ESP_LOGI("led_rpt", "   %s: %s", cat_name.c_str(), status_line.c_str());
          }

          if (registry_empty) {
             ESP_LOGW("led_rpt", ">> WARNING: NO LEDS REGISTERED");
          }
          ESP_LOGI("led_rpt", "--------------------------------");