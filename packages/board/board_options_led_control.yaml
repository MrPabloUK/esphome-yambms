# Updated : 2026.01.31
# Version : 1.1.2
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.


substitutions:
  global_status_led: "esp_light"

globals:
  # 2D grid of physical LED pointers
  # Structure: [Component Category (0-15)] -> [Specific Instance ID (0-N)]
  - id: global_led_registry
    type: std::vector<std::vector<esphome::light::LightState*>>
    initial_value: 'std::vector<std::vector<esphome::light::LightState*>>(16)'

  # ---------------------------------------------------------
  # Global Function: Update LED assignment
  # ---------------------------------------------------------
  - id: global_register_led
    type: std::function<void(int, int, light::LightState*)>
    initial_value: |-
      [](int category, int instance, light::LightState* led) {

        if (led == &id(virtual_status_light)) {
            led = nullptr; 
        }

        int computer_instance = instance - 1;
        if (category < 0 || category >= 16 || computer_instance < 0) return;

        auto &leds = id(global_led_registry)[category];
        auto &faults = id(global_instance_faults)[category];

        if (leds.size() <= computer_instance) {
          leds.resize(computer_instance + 1, nullptr);
          faults.resize(computer_instance + 1, false);
        }
        leds[computer_instance] = led;
      }


output:
  - platform: template
    id: virtual_output
    type: binary
    write_action: []

# Fake light to act as a placeholder for LED control logic
light:
  - platform: binary
    id: virtual_status_light
    output: virtual_output


interval:
  - interval: 50ms
    then:
      - lambda: |-
          // -----------------------------------------------------------------------
          // DATA STRUCTURES FOR PER-LED STATE
          // -----------------------------------------------------------------------
          
          // Structure to hold the runtime state of a single physical LED
          struct LedStateContext {
              int stage;              // 0=Init, 1=HealthyPulse, 10=Header, 11=Gap, 12=Pips, 13=NextFault
              uint32_t next_event_ms; // When to switch to next stage
              int pip_counter;        // Tracking blinks
              size_t fault_index;     // Which fault in the list are we showing?
              bool toggle_bit;        // Helper for blinking
          };

          // Persistent storage for LED states (Key = LightState Pointer)
          static std::map<esphome::light::LightState*, LedStateContext> states;
          
          // Temporary map to group assignments by physical LED for this tick
          // Key: LightState*, Value: List of {Category, Instance} pairs assigned to it
          std::map<esphome::light::LightState*, std::vector<std::pair<int, int>>> assignments;

          // -----------------------------------------------------------------------
          // STEP 1: MAP REGISTRY TO PHYSICAL LEDS
          // -----------------------------------------------------------------------
          // We invert the [Cat][Inst] registry to find out what each LED is responsible for.
          
          for (int cat = 0; cat < 16; cat++) {
             auto &leds_in_cat = id(global_led_registry)[cat];
             for (size_t inst = 0; inst < leds_in_cat.size(); inst++) {
                 auto *led = leds_in_cat[inst];
                 if (led != nullptr) {
                     assignments[led].push_back({cat, (int)inst});
                 }
             }
          }

          // -----------------------------------------------------------------------
          // STEP 2: PROCESS EACH LED INDEPENDENTLY
          // -----------------------------------------------------------------------
          
          uint32_t now = millis();

          for (auto const& [led, assigned_list] : assignments) {
              
              // A. Identify Active Faults for this specific LED
              std::vector<int> active_fault_categories;
              for (auto &pair : assigned_list) {
                  int cat = pair.first;
                  int inst = pair.second;
                  auto &cat_faults = id(global_instance_faults)[cat];
                  
                  // Check if this specific instance is faulted
                  if (inst < cat_faults.size() && cat_faults[inst]) {
                      active_fault_categories.push_back(cat);
                  }
              }

              // B. Retrieve or Initialize State Context
              LedStateContext &ctx = states[led];
              
              // C. Timer Check (Non-blocking)
              // If we haven't reached the next event time, skip logic but KEEP LED ON if needed
              if ((int32_t)(now - ctx.next_event_ms) < 0) continue;

              float bri = 0.5;

              // -------------------------------------------------------------------
              // LOGIC BRANCH: DETERMINE MODE (Empty vs Healthy vs Faulted)
              // -------------------------------------------------------------------

              // CASE 1: UNASSIGNED / EMPTY
              // (Should technically be caught by assignments map, but safe fallback)
              if (assigned_list.empty()) {
                  led->make_call().set_state(false).perform();
                  continue;
              }

              // CASE 2: HEALTHY (Assignments exist, but Fault list is empty)
              if (active_fault_categories.empty()) {
                  // Reset Fault State vars
                  ctx.fault_index = 0; 
                  
                  // Simple 1Hz Pulse State Machine
                  // Stage 1 = ON, Stage 2 = OFF
                  if (ctx.stage != 1 && ctx.stage != 2) ctx.stage = 1; // Force start

                  auto call = led->make_call();
                  if (ctx.stage == 1) {
                      // Pulse ON (Green)
                      if (${board_has_rgb}) { call.set_rgb(0.0, 1.0, 0.0); }
                      call.set_brightness(bri).set_state(true);
                      ctx.stage = 2;
                      ctx.next_event_ms = now + 1000; // 1 second ON
                  } else {
                      // Pulse OFF
                      call.set_state(false);
                      ctx.stage = 1;
                      ctx.next_event_ms = now + 1000; // 1 second OFF
                  }
                  call.perform();
                  continue;
              }

              // CASE 3: FAULTED (Active faults exist)
              // We cycle through active_fault_categories using ctx.fault_index
              
              // Sanity check index
              if (ctx.fault_index >= active_fault_categories.size()) ctx.fault_index = 0;
              
              int current_cat = active_fault_categories[ctx.fault_index];
              int pips_needed = current_cat + 1; // Cat 0 = 1 pip, Cat 1 = 2 pips...

              // Initialize Fault Sequence if coming from Healthy
              if (ctx.stage < 10) ctx.stage = 10;

              auto call = led->make_call();

              switch (ctx.stage) {
                  
                  // --- HEADER: BLUE PULSE ---
                  case 10: 
                      if (${board_has_rgb}) { call.set_rgb(0.0, 0.0, 1.0); }
                      call.set_brightness(bri).set_state(true);
                      call.perform();
                      
                      ctx.stage = 11;
                      ctx.next_event_ms = now + 1000; // Blue for 1s
                      break;

                  // --- GAP: DARK BEFORE PIPS ---
                  case 11:
                      call.set_state(false).perform();
                      
                      ctx.pip_counter = 0;
                      ctx.toggle_bit = true; // Start with ON
                      ctx.stage = 12;
                      ctx.next_event_ms = now + 500; // Dark for 500ms
                      break;

                  // --- PIPS: RED BLINKS ---
                  case 12:
                      if (ctx.pip_counter < (pips_needed * 2)) {
                          if (ctx.toggle_bit) {
                              // Turn ON (Red)
                              if (${board_has_rgb}) { call.set_rgb(1.0, 0.0, 0.0); }
                              call.set_brightness(bri).set_state(true);
                          } else {
                              // Turn OFF
                              call.set_state(false);
                          }
                          call.perform();

                          // Timing: If we just turned ON, wait 150ms. If OFF, wait 150ms.
                          // (Unless we want grouped pips, but let's keep it simple for now)
                          ctx.next_event_ms = now + 150;
                          
                          ctx.toggle_bit = !ctx.toggle_bit;
                          ctx.pip_counter++;
                      } else {
                          // All pips done
                          ctx.stage = 13;
                          ctx.next_event_ms = now + 500; // Wait before next fault
                      }
                      break;

                  // --- NEXT FAULT: PREPARE LOOP ---
                  case 13:
                      call.set_state(false).perform(); // Ensure OFF
                      
                      ctx.fault_index++; // Move to next fault in the list
                      ctx.stage = 10;    // Restart at Blue Header
                      ctx.next_event_ms = now + 100; // Tiny pause before restarting
                      break;
              }
          }



  # LED Assignment Report in logs, enabled via enable_led_logging substitution
  - interval: 60s
    then:
      - lambda: |-
          // If the substitution is false, stop
          if (!${enable_led_logging}) return;

          ESP_LOGI("led_rpt", "┌──────────────────────────────┐");
          ESP_LOGI("led_rpt", "│    LED REGISTRY ASSIGNMENT   │");
          ESP_LOGI("led_rpt", "└──────────────────────────────┘");

          bool registry_empty = true;

          for (int cat = 0; cat < 16; cat++) {
            // Access the LED Registry
            auto &leds = id(global_led_registry)[cat];
            
            // Skip empty categories
            if (leds.empty()) continue;
            registry_empty = false;

            // Translate ID to Name
            std::string cat_name;
            switch(cat) {
                case 0: cat_name = "SYSTEM     "; break;
                case 1: cat_name = "BMS        "; break;
                case 2: cat_name = "CAN->INV   "; break;
                case 3: cat_name = "RS485->INV "; break;
                case 4: cat_name = "SHUNT      "; break;
                case 5: cat_name = "BALANCER   "; break;
                case 6: cat_name = "NETWORK    "; break;
                case 7: cat_name = "AUX 1      "; break;
                default: cat_name = "CAT_" + to_string(cat) + "     "; break;
            }

            // Build the status string for this category's LEDs
            std::string status_line = "";
            
            for (size_t i = 0; i < leds.size(); i++) {
                // Check if the pointer is valid
                if (leds[i] != nullptr) {
                    status_line += "[LINK] ";
                } else {
                    status_line += "[NULL] ";
                }
            }

            ESP_LOGI("led_rpt", "   %s: %s", cat_name.c_str(), status_line.c_str());
          }

          if (registry_empty) {
             ESP_LOGW("led_rpt", ">> WARNING: NO LEDS REGISTERED");
          }
          ESP_LOGI("led_rpt", "--------------------------------");
