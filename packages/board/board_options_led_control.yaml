# Updated : 2026.01.31
# Version : 1.1.2
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.


substitutions:
  global_status_led: "esp_light"

globals:
  # 2D grid of physical LED pointers
  # Structure: [Component Category (0-15)] -> [Specific Instance ID (0-N)]
  - id: global_led_registry
    type: std::vector<std::vector<esphome::light::LightState*>>
    initial_value: 'std::vector<std::vector<esphome::light::LightState*>>(16)'

  # ---------------------------------------------------------
  # Global Function: Update LED assignment
  # ---------------------------------------------------------
  - id: global_register_led
    type: std::function<void(int, int, light::LightState*)>
    initial_value: |-
      [](int category, int instance, light::LightState* led) {

        if (led == &id(virtual_status_light)) {
            led = nullptr; 
        }

        int computer_instance = instance - 1;
        if (category < 0 || category >= 16 || computer_instance < 0) return;

        auto &leds = id(global_led_registry)[category];
        auto &faults = id(global_instance_faults)[category];

        if (leds.size() <= computer_instance) {
          leds.resize(computer_instance + 1, nullptr);
          faults.resize(computer_instance + 1, false);
        }
        leds[computer_instance] = led;
      }


output:
  - platform: template
    id: virtual_output
    type: binary
    write_action: []

# Fake light to act as a placeholder for LED control logic
light:
  - platform: binary
    id: virtual_status_light
    output: virtual_output


interval:
  - interval: 50ms
    then:
      - lambda: |-
          // --- STATE VARIABLES ---
          static int current_stage = 0;       // 0=Search, 1=BlueHeader, 2=RedPips, 3=Reset
          static int active_category = -1;    // The category currently being broadcast
          static int pips_count = 0;          
          static uint32_t next_event_ms = 0;  

          uint32_t now = millis();
          float bri = 0.5;
          bool hb_on = (now % 2000) < 1000; // 1s ON, 1s OFF

          // =================================================================
          // STEP 1: IDENTIFY UNIQUE LEDS & THEIR STATUS
          // We must scan the registry to find every unique physical LED and 
          // determine if it is purely healthy or has any faults.
          // =================================================================
          
          std::vector<esphome::light::LightState*> processed_leds;

          // Iterate through all 16 categories to find LEDs
          for (int cat_scan = 0; cat_scan < 16; cat_scan++) {
             auto &registry_row = id(global_led_registry)[cat_scan];
             
             for (auto *led : registry_row) {
                if (led == nullptr) continue;

                // Check if we already processed this LED in this cycle
                bool already_processed = false;
                for (auto *p : processed_leds) { if (p == led) { already_processed = true; break; } }
                if (already_processed) continue;

                // Mark as processed so we don't control it twice
                processed_leds.push_back(led);

                // --- DIAGNOSE THIS LED ---
                bool led_has_any_fault = false;
                bool led_is_active_for_current_fault = false;

                // Re-scan the registry to find ALL assignments for THIS specific LED
                for (int c = 0; c < 16; c++) {
                   auto &check_leds = id(global_led_registry)[c];
                   auto &check_faults = id(global_instance_faults)[c];

                   for (size_t i = 0; i < check_leds.size(); i++) {
                      if (check_leds[i] == led) {
                         // Found an assignment for this LED. Is it faulty?
                         if (i < check_faults.size() && check_faults[i]) {
                            led_has_any_fault = true;
                            // Is this the fault currently being broadcast by the State Machine?
                            if (c == active_category) {
                               led_is_active_for_current_fault = true;
                            }
                         }
                      }
                   }
                }

                // --- APPLY LOGIC BASED ON DIAGNOSIS ---
                auto call = led->make_call();

                if (!led_has_any_fault) {
                    // REQUIREMENT 1: No instances unhealthy -> Pulse Green
                    if (${board_has_rgb}) { call.set_rgb(0.0, 1.0, 0.0); call.set_brightness(bri); }
                    call.set_state(hb_on);
                    call.perform();
                } 
                else {
                    // REQUIREMENT 2: Any instance unhealthy -> Fault Mode
                    // "Do not show green pulses"
                    
                    if (led_is_active_for_current_fault && current_stage > 0) {
                        // This LED owns the current time slot. Show the Pattern.
                        // (The actual pattern logic is applied below in the State Machine section,
                        //  but we set the "base" state here to ensure it's on).
                        // Logic below will handle colors/blinking.
                    } else {
                        // REQUIREMENT 3 / WAIT STATE:
                        // This LED is faulty, but it's not its turn to speak.
                        // Stay Dark.
                        call.set_state(false);
                        call.perform();
                    }
                }
             }
          }

          // =================================================================
          // STEP 2: GLOBAL FAULT STATE MACHINE
          // Cycles through faulty categories one by one.
          // =================================================================
          
          if (now < next_event_ms) return; 

          switch (current_stage) {
            
            // SEARCH: Find the next faulty category
            case 0: 
              for (int i = 1; i <= 16; i++) {
                int search_target = (active_category + i) % 16;
                bool is_faulted = (id(global_system_fault_mask) >> search_target) & 1;
                
                // Do valid LEDs exist for this fault?
                bool has_led = false;
                if (is_faulted) {
                    for (auto *ptr : id(global_led_registry)[search_target]) {
                        if (ptr) { has_led = true; break; }
                    }
                }

                if (is_faulted && has_led) {
                    active_category = search_target;
                    current_stage = 1; 
                    return; 
                }
              }
              active_category = -1; // No faults in system
              return;

            // STAGE 1: BLUE HEADER (Pulse Blue)
            case 1: 
              // Turn ON the specific LEDs for this active category
              for (auto *led : id(global_led_registry)[active_category]) {
                if (!led) continue;
                // Only turn on if this specific instance is actually faulty? 
                // Requirement says "Loop through all faults". 
                // Usually Header is broad, but let's be precise.
                auto &faults = id(global_instance_faults)[active_category];
                // Check if this LED is linked to a faulty instance
                bool is_relevant = false;
                auto &leds = id(global_led_registry)[active_category];
                for(size_t k=0; k<leds.size(); k++) {
                    if(leds[k] == led && k < faults.size() && faults[k]) is_relevant = true;
                }

                if (is_relevant) {
                    auto call = led->make_call();
                    if (${board_has_rgb}) call.set_rgb(0.0, 0.0, 1.0); // Blue
                    call.set_state(true); 
                    call.perform();
                }
              }
              current_stage = 2; pips_count = 0; next_event_ms = now + 1000;
              break;

            // STAGE 2: RED PIPS
            case 2: 
              {
                int total_toggles = (active_category + 1) * 2; 

                // Gap (Dark)
                if (pips_count == 0) {
                    for (auto *led : id(global_led_registry)[active_category]) {
                       if(led) led->make_call().set_state(false).perform();
                    }
                    pips_count = 1; next_event_ms = now + 500;
                    return;
                }

                // Pips (Red)
                bool is_on = (pips_count % 2 != 0); 
                for (size_t i = 0; i < id(global_led_registry)[active_category].size(); i++) {
                   auto *led = id(global_led_registry)[active_category][i];
                   auto &faults = id(global_instance_faults)[active_category];
                   
                   if (led && i < faults.size() && faults[i]) {
                      auto call = led->make_call();
                      if (is_on) {
                        if (${board_has_rgb}) call.set_rgb(1.0, 0.0, 0.0); 
                        call.set_state(true);
                      } else { 
                        call.set_state(false); 
                      }
                      call.perform();
                   }
                }
                
                pips_count++;
                int delay = (pips_count > 1 && (pips_count - 1) % 8 == 0) ? 500 : 150;
                next_event_ms = (pips_count <= total_toggles) ? now + delay : now + 500;
                if (pips_count > total_toggles) current_stage = 3;
              }
              break;

            // STAGE 3: CLEANUP
            case 3: 
              for (auto *led : id(global_led_registry)[active_category]) {
                 if(led) led->make_call().set_state(false).perform();
              }
              current_stage = 0; next_event_ms = now; 
              break;
          }



  # LED Assignment Report in logs, enabled via enable_led_logging substitution
  - interval: 60s
    then:
      - lambda: |-
          // If the substitution is false, stop
          if (!${enable_led_logging}) return;

          ESP_LOGI("led_rpt", "┌──────────────────────────────┐");
          ESP_LOGI("led_rpt", "│    LED REGISTRY ASSIGNMENT   │");
          ESP_LOGI("led_rpt", "└──────────────────────────────┘");

          bool registry_empty = true;

          for (int cat = 0; cat < 16; cat++) {
            // Access the LED Registry
            auto &leds = id(global_led_registry)[cat];
            
            // Skip empty categories
            if (leds.empty()) continue;
            registry_empty = false;

            // Translate ID to Name
            std::string cat_name;
            switch(cat) {
                case 0: cat_name = "SYSTEM     "; break;
                case 1: cat_name = "BMS        "; break;
                case 2: cat_name = "CAN->INV   "; break;
                case 3: cat_name = "RS485->INV "; break;
                case 4: cat_name = "SHUNT      "; break;
                case 5: cat_name = "BALANCER   "; break;
                case 6: cat_name = "NETWORK    "; break;
                case 7: cat_name = "AUX 1      "; break;
                default: cat_name = "CAT_" + to_string(cat) + "     "; break;
            }

            // Build the status string for this category's LEDs
            std::string status_line = "";
            
            for (size_t i = 0; i < leds.size(); i++) {
                // Check if the pointer is valid
                if (leds[i] != nullptr) {
                    status_line += "[LINK] ";
                } else {
                    status_line += "[NULL] ";
                }
            }

            ESP_LOGI("led_rpt", "   %s: %s", cat_name.c_str(), status_line.c_str());
          }

          if (registry_empty) {
             ESP_LOGW("led_rpt", ">> WARNING: NO LEDS REGISTERED");
          }
          ESP_LOGI("led_rpt", "--------------------------------");