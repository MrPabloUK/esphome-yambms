# Updated : 2026.01.31
# Version : 1.1.2
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.


substitutions:
  global_status_led: "esp_light"

globals:
  # 2D grid of physical LED pointers
  # Structure: [Component Category (0-15)] -> [Specific Instance ID (0-N)]
  - id: global_led_registry
    type: std::vector<std::vector<esphome::light::LightState*>>
    initial_value: 'std::vector<std::vector<esphome::light::LightState*>>(16)'

  # ---------------------------------------------------------
  # Global Function: Update LED assignment
  # ---------------------------------------------------------
  - id: global_register_led
    type: std::function<void(int, int, light::LightState*)>
    initial_value: |-
      [](int category, int instance, light::LightState* led) {

        if (led == &id(virtual_status_light)) {
            led = nullptr; 
        }

        int computer_instance = instance - 1;
        if (category < 0 || category >= 16 || computer_instance < 0) return;

        auto &leds = id(global_led_registry)[category];
        auto &faults = id(global_instance_faults)[category];

        if (leds.size() <= computer_instance) {
          leds.resize(computer_instance + 1, nullptr);
          faults.resize(computer_instance + 1, false);
        }
        leds[computer_instance] = led;
      }


output:
  - platform: template
    id: virtual_output
    type: binary
    write_action: []

# Fake light to act as a placeholder for LED control logic
light:
  - platform: binary
    id: virtual_status_light
    output: virtual_output


interval:
  - interval: 50ms
    then:
      - lambda: |-
          static const uint32_t HEADER_DUR = 1000;
          static const uint32_t GAP_DUR = 500;
          static const uint32_t PIP_ON_DUR = 200;
          static const uint32_t PIP_OFF_DUR = 200;
          static const uint32_t POST_SEQ_DUR = 1000;

          uint32_t now = millis();
          bool hb_on = (now % 2000) < 1000; // Global Heartbeat Rhythm

          // -----------------------------------------------------------------
          // 1. DATA GATHERING
          // Build a temporary map of what every LED is responsible for right now.
          // -----------------------------------------------------------------
          
          struct LedWorkload {
              std::vector<int> faulty_categories; // List of error codes to flash
              bool has_healthy = false;           // Should it pulse green if no faults?
          };
          std::map<esphome::light::LightState*, LedWorkload> workload_map;

          // Scan the entire registry
          for (int cat = 0; cat < 16; cat++) {
             auto &leds = id(global_led_registry)[cat];
             auto &faults = id(global_instance_faults)[cat];

             for (size_t i = 0; i < leds.size(); i++) {
                auto *led = leds[i];
                if (!led) continue;

                // Create entry if not exists
                if (workload_map.find(led) == workload_map.end()) {
                    workload_map[led] = LedWorkload();
                }

                // Check Status
                bool is_failing = (i < faults.size() && faults[i]);
                
                if (is_failing) {
                    // Avoid duplicate categories for the same LED (e.g. 2 broken batteries on same LED)
                    bool already_listed = false;
                    for(int c : workload_map[led].faulty_categories) { if(c == cat) already_listed = true; }
                    
                    if (!already_listed) {
                        workload_map[led].faulty_categories.push_back(cat);
                    }
                } else {
                    workload_map[led].has_healthy = true;
                }
             }
          }

          // -----------------------------------------------------------------
          // 2. STATE TRACKING
          // Persist the current animation state for each LED between cycles
          // -----------------------------------------------------------------
          
          struct LedState {
              int playlist_index = 0;   // Which fault in the vector are we showing?
              int stage = 0;            // 0=Init, 1=Header, 2=Gap, 3=PipOn, 4=PipOff, 5=Wait
              int pips_remaining = 0;   // How many blinks left for current code?
              uint32_t next_event = 0;  // When to switch stage
          };
          static std::map<esphome::light::LightState*, LedState> states;

          // -----------------------------------------------------------------
          // 3. EXECUTION LOOP
          // Process each physical LED exactly once based on its workload
          // -----------------------------------------------------------------

          for (auto const& [led, load] : workload_map) {
              auto call = led->make_call();
              LedState &st = states[led]; // Get or create state context

              // --- CASE A: NO FAULTS (HEARTBEAT) ---
              if (load.faulty_categories.empty()) {
                  // Reset state for next time a fault happens
                  st.playlist_index = 0;
                  st.stage = 0;
                  
                  if (load.has_healthy) {
                      if (${board_has_rgb}) { call.set_rgb(0.0, 1.0, 0.0); call.set_brightness(0.5); }
                      call.set_state(hb_on);
                  } else {
                      call.set_state(false); // Assigned but no healthy devices? Dark.
                  }
                  call.perform();
                  continue; 
              }

              // --- CASE B: ACTIVE FAULTS (ANIMATION SEQUENCE) ---
              
              // 0. Safety: Check if playlist index is out of bounds (fault cleared mid-cycle)
              if (st.playlist_index >= load.faulty_categories.size()) {
                  st.playlist_index = 0;
                  st.stage = 0; // Restart sequence
                  st.next_event = now;
              }

              // If waiting for timer, do nothing (keep current light state)
              if (now < st.next_event) continue;

              // State Machine
              int current_cat = load.faulty_categories[st.playlist_index];

              switch (st.stage) {
                  case 0: // INIT NEW CODE
                      st.stage = 1;
                      st.pips_remaining = current_cat + 1; // Cat 0 = 1 pip
                      st.next_event = now; // Immediate transition
                      break;

                  case 1: // BLUE HEADER
                      if (${board_has_rgb}) { call.set_rgb(0.0, 0.0, 1.0); call.set_brightness(0.5); }
                      call.set_state(true);
                      call.perform();
                      
                      st.stage = 2;
                      st.next_event = now + HEADER_DUR;
                      break;

                  case 2: // PRE-PIP GAP (DARK)
                      call.set_state(false);
                      call.perform();
                      
                      st.stage = 3;
                      st.next_event = now + GAP_DUR;
                      break;

                  case 3: // PIP ON (RED)
                      if (${board_has_rgb}) { call.set_rgb(1.0, 0.0, 0.0); call.set_brightness(0.5); }
                      call.set_state(true);
                      call.perform();

                      st.stage = 4;
                      st.next_event = now + PIP_ON_DUR;
                      break;

                  case 4: // PIP OFF (DARK)
                      call.set_state(false);
                      call.perform();
                      
                      st.pips_remaining--;
                      if (st.pips_remaining > 0) {
                          st.stage = 3; // Back to Pip ON
                          st.next_event = now + PIP_OFF_DUR;
                      } else {
                          st.stage = 5; // Sequence Done
                          st.next_event = now + PIP_OFF_DUR;
                      }
                      break;

                  case 5: // INTER-SEQUENCE DELAY (DARK)
                      call.set_state(false);
                      call.perform();

                      // Advance to next fault in the playlist
                      st.playlist_index++;
                      if (st.playlist_index >= load.faulty_categories.size()) {
                          st.playlist_index = 0; // Loop back to start
                      }
                      
                      st.stage = 0; // Ready for next code
                      st.next_event = now + POST_SEQ_DUR;
                      break;
              }
          }



  # LED Assignment Report in logs, enabled via enable_led_logging substitution
  - interval: 60s
    then:
      - lambda: |-
          // If the substitution is false, stop
          if (!${enable_led_logging}) return;

          ESP_LOGI("led_rpt", "┌──────────────────────────────┐");
          ESP_LOGI("led_rpt", "│    LED REGISTRY ASSIGNMENT   │");
          ESP_LOGI("led_rpt", "└──────────────────────────────┘");

          bool registry_empty = true;

          for (int cat = 0; cat < 16; cat++) {
            // Access the LED Registry
            auto &leds = id(global_led_registry)[cat];
            
            // Skip empty categories
            if (leds.empty()) continue;
            registry_empty = false;

            // Translate ID to Name
            std::string cat_name;
            switch(cat) {
                case 0: cat_name = "SYSTEM     "; break;
                case 1: cat_name = "BMS        "; break;
                case 2: cat_name = "CAN->INV   "; break;
                case 3: cat_name = "RS485->INV "; break;
                case 4: cat_name = "SHUNT      "; break;
                case 5: cat_name = "BALANCER   "; break;
                case 6: cat_name = "NETWORK    "; break;
                case 7: cat_name = "AUX 1      "; break;
                default: cat_name = "CAT_" + to_string(cat) + "     "; break;
            }

            // Build the status string for this category's LEDs
            std::string status_line = "";
            
            for (size_t i = 0; i < leds.size(); i++) {
                // Check if the pointer is valid
                if (leds[i] != nullptr) {
                    status_line += "[LINK] ";
                } else {
                    status_line += "[NULL] ";
                }
            }

            ESP_LOGI("led_rpt", "   %s: %s", cat_name.c_str(), status_line.c_str());
          }

          if (registry_empty) {
             ESP_LOGW("led_rpt", ">> WARNING: NO LEDS REGISTERED");
          }
          ESP_LOGI("led_rpt", "--------------------------------");