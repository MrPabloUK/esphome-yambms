# Updated : 2025.12.30
# Version : 1.0.0
# GitHub  : https://github.com/Sleeper85/esphome-yambms

# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

  # +-------------------------------------------------------------------------+
  # | Temperature-based current limitation                                    |
  # | Can be disabled via the switch "Temperature-based current limitation"   |
  # | This factor is applied to the battery capacity (Ah), not the current    |
  # | maximum charge/discharge current. For example : 280Ah x 0.5 = 140A      |
  # +-------------------------------------------------------------------------

globals:
  - id: charging_table
    type: std::map<float, float>
    initial_value: '${yambms_charging_rate_table}'

  - id: discharging_table
    type: std::map<float, float>
    initial_value: '${yambms_discharging_rate_table}'

switch:
  - platform: template
    name: "${name} ${yambms_name} Temperature-based Current Limitation"
    id: ${yambms_id}_switch_temperature_based_current_limitation
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: config

sensor:
  # +---------------------------------------+
  # | Auto Charge Current Temperature Limit |
  # +---------------------------------------+
  - platform: template
    id: auto_ccl_temp_limit
    unit_of_measurement: "A"
    device_class: current
    internal: true
    update_interval: ${yambms_update_interval}
    lambda: |-
      // Check if the logic is enabled via the switch
      if (!id(${yambms_id}_switch_temperature_based_current_limitation).state) {
        return 0.0f; 
      }

      // Variables
      static float s_min_temp = NAN;
      static float s_max_temp = NAN;

      float raw_min = id(${yambms_id}_min_temperature).state;
      float raw_max = id(${yambms_id}_max_temperature).state;

      // Exit if sensors aren't ready
      if (isnan(raw_min) || isnan(raw_max)) return 0.0f;

      // If first run (NAN) OR if the difference is > 5.0°C (potentially indicates a boot glitch)
      if (isnan(s_min_temp) || std::abs(raw_min - s_min_temp) > 5.0f || std::abs(raw_max - s_max_temp) > 5.0f) {
        s_min_temp = raw_min;
        s_max_temp = raw_max;
        ESP_LOGI("YamBMS_CCL", "Filter Snapped to Reality: %.1f°C", raw_min);
      } else {
        // Normal Input Smoothing
        float alpha = 0.15f;
        s_min_temp = (alpha * raw_min) + ((1.0f - alpha) * s_min_temp);
        s_max_temp = (alpha * raw_max) + ((1.0f - alpha) * s_max_temp);
      }

      // Input Smoothing
      float alpha = 0.15f;
      s_min_temp = (alpha * raw_min) + ((1.0f - alpha) * s_min_temp);
      s_max_temp = (alpha * raw_max) + ((1.0f - alpha) * s_max_temp);

      // Interpolation
      auto interpolate = [](const std::map<float, float>& m, float x) -> float {
        if (m.empty()) return 0.0f;
        if (x <= m.begin()->first) return m.begin()->second;
        if (x >= m.rbegin()->first) return m.rbegin()->second;
        auto it_upper = m.upper_bound(x);
        auto it_lower = std::prev(it_upper);
        float x0 = it_lower->first, y0 = it_lower->second;
        float x1 = it_upper->first, y1 = it_upper->second;
        return y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
      };

      // Calculate allowed current
      float rate_low = interpolate(id(charging_table), s_min_temp);
      float rate_high = interpolate(id(charging_table), s_max_temp);
      float allowed_rate = std::min(rate_low, rate_high);

      // Calculate current delta
      float batt_capacity = id(${yambms_id}_battery_capacity).state;
      float max_charge_current = id(${yambms_id}_max_charge_current).state;
      
      float target_current = allowed_rate * batt_capacity;
      
      // Delta = Target - Max. 
      // If Target is 30A and Max is 100A, Delta is -70A.
      float delta = target_current - max_charge_current;

      // Clamp and round
      if (delta > 0.0f) delta = 0.0f;
      delta = roundf(delta * 10.0f) / 10.0f;

      // LOGGING
      ESP_LOGI("YamBMS_CCL", "Temp Raw:%.1f, Filtered:%.1f | Rate:%.3f | Target:%.1fA | Delta:%.1f", 
               raw_min, s_min_temp, allowed_rate, target_current, delta);

      id(${yambms_id}_auto_temperature_ccl) = delta;
      return delta;

  # +------------------------------------------+
  # | Auto Discharge Current Temperature Limit |
  # +------------------------------------------+
  - platform: template
    id: auto_dcl_temp_limit
    unit_of_measurement: "A"
    device_class: current
    internal: true
    update_interval: ${yambms_update_interval}
    lambda: |-
      // Check if the logic is enabled via the switch
      if (!id(${yambms_id}_switch_temperature_based_current_limitation).state) {
        return 0.0f; 
      }

      // Variables
      static float s_min_temp = NAN;
      static float s_max_temp = NAN;

      float raw_min = id(${yambms_id}_min_temperature).state;
      float raw_max = id(${yambms_id}_max_temperature).state;

      // Exit if sensors aren't ready
      if (isnan(raw_min) || isnan(raw_max)) return 0.0f;

      // Update with actual temperature data
      if (isnan(s_min_temp)) {
        s_min_temp = raw_min;
        s_max_temp = raw_max;
      }

      // Input Smoothing
      float alpha = 0.15f;
      s_min_temp = (alpha * raw_min) + ((1.0f - alpha) * s_min_temp);
      s_max_temp = (alpha * raw_max) + ((1.0f - alpha) * s_max_temp);

      // Interpolation
      auto interpolate = [](const std::map<float, float>& m, float x) -> float {
        if (m.empty()) return 0.0f;
        if (x <= m.begin()->first) return m.begin()->second;
        if (x >= m.rbegin()->first) return m.rbegin()->second;
        auto it_upper = m.upper_bound(x);
        auto it_lower = std::prev(it_upper);
        float x0 = it_lower->first, y0 = it_lower->second;
        float x1 = it_upper->first, y1 = it_upper->second;
        return y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
      };

      // Calculate allowed current
      float rate_low = interpolate(id(discharging_table), s_min_temp);
      float rate_high = interpolate(id(discharging_table), s_max_temp);
      float allowed_rate = std::min(rate_low, rate_high);

      // Calculate current delta
      float batt_capacity = id(${yambms_id}_battery_capacity).state;
      float max_discharge_current = id(${yambms_id}_max_discharge_current).state;
      
      float target_current = allowed_rate * batt_capacity;
      
      // Delta = Target - Max. 
      // If Target is 30A and Max is 100A, Delta is -70A.
      float delta = target_current - max_discharge_current;

      // Clamp and round
      if (delta > 0.0f) delta = 0.0f;
      delta = roundf(delta * 10.0f) / 10.0f;
      id(${yambms_id}_auto_temperature_dcl) = delta;
      return delta;